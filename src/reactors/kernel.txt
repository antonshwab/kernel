
Queues
======

pub struct Subscriber<T> {
    ring: Arc<RingBuffer<T>>,
    token: usize,
    next_seq_cache: Cell<Sequence>,
    cursors: UncheckedUnsafeArc<Vec<Cursor>>,
}

pub struct Publisher<T> {
    ring: Arc<RingBuffer<T>>,
    next_seq_cache: Cell<Sequence>,
    cursors: UncheckedUnsafeArc<Vec<Cursor>>,
}

pub struct Channel {
    publisher: Publisher<u64>,
    subscribers: Vec<Subscriber<u64>>,
}

Reactors
========

pub struct Core<'a> {
    scheduler: Scheduler<'a, Job<'a>>,
    bus: UnsafeCell<Channel>,
    io: IO,
}

pub struct Machine<'a> {
    junk: Handle<Core<'a>>,
    cores: Vec<Core<'a>>,
}

pub struct Scheduler<'a, T: 'a> {
    tasks: Vec<(T, TaskTermination)>,
    ctxs: Vec<Context<'a>>,
}

pub enum TaskTermination {
    Recursive,
    Corecursive,
}

pub enum Context<'a> {
    Cont(usize),
    Node(&'a AST<'a>),
    Nil,
}

pub struct CpsTask<'a> {
    interpreter: Interpreter<'a>,
    ast: Option<&'a AST<'a>>,
}

pub trait Task<'a> {
    fn init(&'a mut self, input: Option<&'a str>);
    fn exec(&'a mut self, input: Option<&'a str>);
    fn poll(&'a mut self, c: Context<'a>) -> Poll<Context<'a>, Error>;
    fn finalize(&'a mut self);
}

pub struct IO {
    tokens: usize,
    events: Events,
    poll: Poll,
    selectors: Vec<Selector>,
    slots: Vec<usize>,
    running: bool,
    i: usize,
}

pub enum Job<'a> {
    Cps(CpsTask<'a>),
    Rust(RustTask<'a>),
}

pub enum Selector {
    Ws(WsServer),
    Rx(Console),
    Sb(Subscriber<Message>),
}
